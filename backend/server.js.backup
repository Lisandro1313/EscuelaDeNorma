const express = require('express');
const cors = require('cors');
const helmet = require('helmet');
const bcrypt = require('bcryptjs');
const jwt = require('jsonwebtoken');
const { createServer } = require('http');
const { Server } = require('socket.io');
const multer = require('multer');
const path = require('path');
require('dotenv').config();

// Importar servicio de MercadoPago
const mercadoPagoService = require('./services/mercadopago');

const app = express();
const server = createServer(app);
const io = new Server(server, {
  cors: {
    origin: "http://localhost:3000",
    methods: ["GET", "POST"]
  }
});

const PORT = process.env.PORT || 5000;
const JWT_SECRET = process.env.JWT_SECRET || 'campus_virtual_secret_2024';

// Middleware
app.use(helmet());
app.use(cors());
app.use(express.json());
app.use(express.urlencoded({ extended: true }));

// Servir archivos estÃ¡ticos
app.use('/uploads', express.static(path.join(__dirname, 'uploads')));

// ConfiguraciÃ³n de Multer para subida de archivos
const storage = multer.diskStorage({
  destination: (req, file, cb) => {
    cb(null, 'uploads/');
  },
  filename: (req, file, cb) => {
    const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1E9);
    cb(null, file.fieldname + '-' + uniqueSuffix + path.extname(file.originalname));
  }
});

const upload = multer({ 
  storage: storage,
  limits: {
    fileSize: 100 * 1024 * 1024 // 100MB lÃ­mite
  },
  fileFilter: (req, file, cb) => {
    const allowedTypes = /jpeg|jpg|png|gif|pdf|mp4|avi|mov|doc|docx|ppt|pptx/;
    const extname = allowedTypes.test(path.extname(file.originalname).toLowerCase());
    const mimetype = allowedTypes.test(file.mimetype);
    
    if (extname && mimetype) {
      return cb(null, true);
    } else {
      cb(new Error('Tipo de archivo no permitido'));
    }
  }
});

// Base de datos simulada (en producciÃ³n usarÃ­as PostgreSQL)
const users = [
  {
    id: 1,
    email: "alumno@campus.com",
    password: "$2b$10$DJQWlAzuxeUUynizQpvFkOk3lYawivZ5dIY6.pGnogwFVPVA0xl.W", // password: 123456
    nombre: "MarÃ­a GonzÃ¡lez",
    tipo: "alumno",
    avatar: "ðŸ‘©â€ðŸŽ“",
    cursosInscritos: [1, 2, 3],
    progreso: { 1: 75, 2: 45, 3: 90 },
    createdAt: new Date()
  },
  {
    id: 2,
    email: "profesor@campus.com",
    password: "$2b$10$DJQWlAzuxeUUynizQpvFkOk3lYawivZ5dIY6.pGnogwFVPVA0xl.W", // password: 123456
    nombre: "Dr. GarcÃ­a LÃ³pez",
    tipo: "profesor",
    avatar: "ðŸ‘¨â€ðŸ«",
    cursosDictados: [1, 4],
    especialidad: "MatemÃ¡ticas",
    createdAt: new Date()
  },
  {
    id: 3,
    email: "admin@campus.com",
    password: "$2b$10$DJQWlAzuxeUUynizQpvFkOk3lYawivZ5dIY6.pGnogwFVPVA0xl.W", // password: 123456
    nombre: "Ana Ruiz",
    tipo: "admin",
    avatar: "ðŸ‘©â€ðŸ’¼",
    permisos: ["gestionar_cursos", "gestionar_usuarios", "ver_reportes"],
    createdAt: new Date()
  }
];

const courses = [
  {
    id: 1,
    nombre: "MatemÃ¡ticas Avanzadas",
    descripcion: "CÃ¡lculo diferencial e integral para estudiantes avanzados",
    profesor: "Dr. GarcÃ­a LÃ³pez",
    profesorId: 2,
    categoria: "matematicas",
    precio: 25,
    duracion: "12 semanas",
    estudiantes: 45,
    rating: 4.8,
    imagen: "ðŸ§®",
    createdAt: new Date(),
    publicado: true,
    modulos: []
  },
  {
    id: 2,
    nombre: "Historia del Arte",
    descripcion: "Un recorrido por las principales corrientes artÃ­sticas",
    profesor: "Mtra. Ana Ruiz",
    profesorId: 3,
    categoria: "arte",
    precio: 20,
    duracion: "8 semanas",
    estudiantes: 32,
    rating: 4.9,
    imagen: "ðŸŽ¨",
    createdAt: new Date(),
    publicado: true,
    modulos: []
  }
];

// MÃ³dulos de cursos (contenido dinÃ¡mico)
const modulos = [
  {
    id: 1,
    cursoId: 1,
    titulo: "IntroducciÃ³n al CÃ¡lculo",
    descripcion: "Conceptos fundamentales y lÃ­mites",
    orden: 1,
    publicado: true,
    createdAt: new Date(),
    lecciones: []
  }
];

// Lecciones dentro de mÃ³dulos
const lecciones = [
  {
    id: 1,
    moduloId: 1,
    titulo: "Â¿QuÃ© es un lÃ­mite?",
    contenido: "En esta lecciÃ³n aprenderemos el concepto fundamental de lÃ­mite en cÃ¡lculo...",
    tipo: "texto", // texto, video, documento, quiz
    orden: 1,
    duracion: 15, // minutos
    recursos: [],
    publicado: true,
    createdAt: new Date()
  }
];

// Recursos de lecciones
const recursos = [
  {
    id: 1,
    leccionId: 1,
    nombre: "Video IntroducciÃ³n a LÃ­mites",
    tipo: "video", // video, pdf, imagen, enlace, archivo
    url: "/uploads/videos/limites_intro.mp4",
    tamaÃ±o: "25MB",
    duracion: 15,
    createdAt: new Date()
  }
];

// Progreso de estudiantes
const progreso = [
  {
    id: 1,
    usuarioId: 1,
    cursoId: 1,
    leccionId: 1,
    completado: true,
    tiempoVisto: 15,
    fechaCompletado: new Date()
  }
];

// Datos de ejemplo para foros
const forumPosts = [
  {
    id: 1,
    autor: "MarÃ­a GarcÃ­a",
    autorId: 1,
    titulo: "Duda sobre integrales",
    contenido: "No entiendo cÃ³mo resolver esta integral por partes...",
    categoria: "matematicas",
    fechaCreacion: new Date(Date.now() - 24 * 60 * 60 * 1000), // Ayer
    respuestas: 3,
    vistas: 45
  },
  {
    id: 2,
    autor: "Dr. GarcÃ­a LÃ³pez",
    autorId: 2,
    titulo: "Recursos adicionales de cÃ¡lculo",
    contenido: "Les comparto algunos ejercicios extra para practicar",
    categoria: "matematicas",
    fechaCreacion: new Date(Date.now() - 2 * 24 * 60 * 60 * 1000), // Hace 2 dÃ­as
    respuestas: 8,
    vistas: 120
  },
  {
    id: 3,
    autor: "Juan PÃ©rez",
    autorId: 4,
    titulo: "AnÃ¡lisis de obras renacentistas",
    contenido: "Â¿Alguien puede ayudarme con el anÃ¡lisis de La Gioconda?",
    categoria: "arte",
    fechaCreacion: new Date(Date.now() - 3 * 24 * 60 * 60 * 1000), // Hace 3 dÃ­as
    respuestas: 5,
    vistas: 67
  }
];

const clases = [
  {
    id: 1,
    cursoId: 1,
    titulo: "Integrales por partes",
    fecha: "2024-10-29",
    hora: "10:00",
    profesorId: 2,
    precio: 25,
    disponible: true,
    estudiantes: [],
    roomId: "clase_1_room"
  }
];

// Middleware de autenticaciÃ³n
const authenticateToken = (req, res, next) => {
  const authHeader = req.headers['authorization'];
  const token = authHeader && authHeader.split(' ')[1];

  if (!token) {
    return res.status(401).json({ error: 'Token de acceso requerido' });
  }

  jwt.verify(token, JWT_SECRET, (err, user) => {
    if (err) {
      return res.status(403).json({ error: 'Token invÃ¡lido' });
    }
    req.user = user;
    next();
  });
};

// Rutas de autenticaciÃ³n
app.post('/api/auth/login', async (req, res) => {
  try {
    const { email, password } = req.body;
    
    const user = users.find(u => u.email === email);
    if (!user) {
      return res.status(401).json({ error: 'Credenciales invÃ¡lidas' });
    }

    const validPassword = await bcrypt.compare(password, user.password);
    if (!validPassword) {
      return res.status(401).json({ error: 'Credenciales invÃ¡lidas' });
    }

    const token = jwt.sign(
      { userId: user.id, email: user.email, tipo: user.tipo },
      JWT_SECRET,
      { expiresIn: '24h' }
    );

    const { password: _, ...userWithoutPassword } = user;
    res.json({
      user: userWithoutPassword,
      token
    });
  } catch (error) {
    res.status(500).json({ error: 'Error interno del servidor' });
  }
});

app.post('/api/auth/register', async (req, res) => {
  try {
    const { email, password, nombre, tipo = 'alumno', teacherCode } = req.body;
    
    // Validaciones bÃ¡sicas
    if (!email || !password || !nombre) {
      return res.status(400).json({ error: 'Todos los campos son obligatorios' });
    }

    if (password.length < 6) {
      return res.status(400).json({ error: 'La contraseÃ±a debe tener al menos 6 caracteres' });
    }

    // Validar email Ãºnico
    if (users.find(u => u.email === email)) {
      return res.status(400).json({ error: 'El email ya estÃ¡ registrado' });
    }

    // Validar cÃ³digo de profesor si es necesario
    const TEACHER_CODE = 'NORMA123';
    if (tipo === 'profesor' && teacherCode !== TEACHER_CODE) {
      return res.status(400).json({ error: 'CÃ³digo de profesor incorrecto' });
    }

    const hashedPassword = await bcrypt.hash(password, 10);
    const newUser = {
      id: users.length + 1,
      email,
      password: hashedPassword,
      nombre,
      tipo,
      avatar: tipo === 'profesor' ? 'ðŸ‘¨â€ðŸ«' : 'ðŸ‘©â€ðŸŽ“',
      departamento: tipo === 'profesor' ? 'Por definir' : undefined,
      carrera: tipo === 'alumno' ? 'Por definir' : undefined,
      semestre: tipo === 'alumno' ? 1 : undefined,
      cursosInscritos: tipo === 'alumno' ? [] : undefined,
      cursosDictados: tipo === 'profesor' ? [] : undefined,
      progreso: tipo === 'alumno' ? {} : undefined,
      notificaciones: [],
      activo: true,
      fechaRegistro: new Date(),
      ultimaConexion: new Date(),
      createdAt: new Date()
    };

    users.push(newUser);
    
    const token = jwt.sign(
      { userId: newUser.id, email: newUser.email, tipo: newUser.tipo },
      JWT_SECRET,
      { expiresIn: '24h' }
    );

    const { password: _, ...userWithoutPassword } = newUser;
    
    console.log(`âœ… Nuevo usuario registrado: ${nombre} (${email}) como ${tipo}`);
    
    res.status(201).json({
      user: userWithoutPassword,
      token,
      message: `Usuario ${tipo} registrado exitosamente`
    });
  } catch (error) {
    console.error('Error en registro:', error);
    res.status(500).json({ error: 'Error interno del servidor' });
  }
});

// Rutas de usuarios
app.get('/api/users/me', authenticateToken, (req, res) => {
  const user = users.find(u => u.id === req.user.userId);
  if (!user) {
    return res.status(404).json({ error: 'Usuario no encontrado' });
  }

  const { password: _, ...userWithoutPassword } = user;
  res.json(userWithoutPassword);
});

// Obtener todos los usuarios (solo para admins)
app.get('/api/users', authenticateToken, (req, res) => {
  const currentUser = users.find(u => u.id === req.user.userId);
  
  if (!currentUser || currentUser.tipo !== 'admin') {
    return res.status(403).json({ error: 'Acceso denegado' });
  }

  const usersWithoutPasswords = users.map(user => {
    const { password, ...userWithoutPassword } = user;
    return userWithoutPassword;
  });

  res.json({
    users: usersWithoutPasswords,
    total: users.length,
    estadisticas: {
      alumnos: users.filter(u => u.tipo === 'alumno').length,
      profesores: users.filter(u => u.tipo === 'profesor').length,
      admins: users.filter(u => u.tipo === 'admin').length,
      activos: users.filter(u => u.activo).length
    }
  });
});

// Obtener estadÃ­sticas de registro
app.get('/api/users/stats', authenticateToken, (req, res) => {
  const currentUser = users.find(u => u.id === req.user.userId);
  
  if (!currentUser || (currentUser.tipo !== 'admin' && currentUser.tipo !== 'profesor')) {
    return res.status(403).json({ error: 'Acceso denegado' });
  }

  // EstadÃ­sticas por dÃ­a (Ãºltimos 7 dÃ­as)
  const hoy = new Date();
  const registrosPorDia = [];
  
  for (let i = 6; i >= 0; i--) {
    const fecha = new Date(hoy);
    fecha.setDate(fecha.getDate() - i);
    fecha.setHours(0, 0, 0, 0);
    
    const fechaSiguiente = new Date(fecha);
    fechaSiguiente.setDate(fechaSiguiente.getDate() + 1);
    
    const registrosDelDia = users.filter(user => {
      const fechaRegistro = new Date(user.fechaRegistro || user.createdAt);
      return fechaRegistro >= fecha && fechaRegistro < fechaSiguiente;
    });

    registrosPorDia.push({
      fecha: fecha.toISOString().split('T')[0],
      total: registrosDelDia.length,
      alumnos: registrosDelDia.filter(u => u.tipo === 'alumno').length,
      profesores: registrosDelDia.filter(u => u.tipo === 'profesor').length
    });
  }

  res.json({
    totalUsuarios: users.length,
    usuariosActivos: users.filter(u => u.activo).length,
    registrosPorDia,
    distribucionTipos: {
      alumnos: users.filter(u => u.tipo === 'alumno').length,
      profesores: users.filter(u => u.tipo === 'profesor').length,
      admins: users.filter(u => u.tipo === 'admin').length
    }
  });
});

// Nuevas rutas administrativas
app.get('/api/admin/stats', authenticateToken, (req, res) => {
  const currentUser = users.find(u => u.id === req.user.userId);
  
  if (!currentUser || currentUser.tipo !== 'admin') {
    return res.status(403).json({ error: 'Acceso denegado' });
  }

  const stats = {
    totalUsers: users.length,
    activeUsers: users.filter(u => u.activo !== false).length,
    totalCourses: courses.length,
    totalForumPosts: forumPosts.length,
    totalCertificates: users.reduce((acc, user) => acc + (user.certificados?.length || 0), 0),
    systemUptime: '2 dÃ­as, 4 horas'
  };

  res.json(stats);
});

// Activar/desactivar usuario
app.patch('/api/admin/users/:userId/toggle-status', authenticateToken, (req, res) => {
  const currentUser = users.find(u => u.id === req.user.userId);
  
  if (!currentUser || currentUser.tipo !== 'admin') {
    return res.status(403).json({ error: 'Acceso denegado' });
  }

  const userId = parseInt(req.params.userId);
  const user = users.find(u => u.id === userId);

  if (!user) {
    return res.status(404).json({ error: 'Usuario no encontrado' });
  }

  if (user.tipo === 'admin') {
    return res.status(403).json({ error: 'No se puede desactivar un administrador' });
  }

  user.activo = !user.activo;
  
  res.json({ 
    message: `Usuario ${user.activo ? 'activado' : 'desactivado'} correctamente`,
    user: { id: user.id, nombre: user.nombre, activo: user.activo }
  });
});

// Eliminar usuario
app.delete('/api/admin/users/:userId', authenticateToken, (req, res) => {
  const currentUser = users.find(u => u.id === req.user.userId);
  
  if (!currentUser || currentUser.tipo !== 'admin') {
    return res.status(403).json({ error: 'Acceso denegado' });
  }

  const userId = parseInt(req.params.userId);
  const userIndex = users.findIndex(u => u.id === userId);

  if (userIndex === -1) {
    return res.status(404).json({ error: 'Usuario no encontrado' });
  }

  const user = users[userIndex];
  
  if (user.tipo === 'admin') {
    return res.status(403).json({ error: 'No se puede eliminar un administrador' });
  }

  users.splice(userIndex, 1);
  
  res.json({ 
    message: `Usuario ${user.nombre} eliminado correctamente`
  });
});

// Rutas para estudiantes
app.get('/api/student/courses', authenticateToken, (req, res) => {
  const currentUser = users.find(u => u.id === req.user.userId);
  
  if (!currentUser || currentUser.tipo !== 'alumno') {
    return res.status(403).json({ error: 'Acceso solo para estudiantes' });
  }

  // Simular cursos inscritos del estudiante
  const cursosInscritos = courses.filter(curso => 
    currentUser.cursosInscritos && currentUser.cursosInscritos.includes(curso.id)
  );

  res.json(cursosInscritos);
});

app.get('/api/student/progress', authenticateToken, (req, res) => {
  const currentUser = users.find(u => u.id === req.user.userId);
  
  if (!currentUser || currentUser.tipo !== 'alumno') {
    return res.status(403).json({ error: 'Acceso solo para estudiantes' });
  }

  // Datos de ejemplo de progreso
  const progresoEjemplo = [
    {
      cursoId: 1,
      nombreCurso: "MatemÃ¡ticas Avanzadas",
      progreso: 75,
      ultimaActividad: "Hace 2 horas",
      proximaClase: "MaÃ±ana 10:00 AM"
    },
    {
      cursoId: 2,
      nombreCurso: "Historia del Arte",
      progreso: 45,
      ultimaActividad: "Ayer",
      proximaClase: "Viernes 2:00 PM"
    }
  ];

  res.json(progresoEjemplo);
});

app.get('/api/student/achievements', authenticateToken, (req, res) => {
  const currentUser = users.find(u => u.id === req.user.userId);
  
  if (!currentUser || currentUser.tipo !== 'alumno') {
    return res.status(403).json({ error: 'Acceso solo para estudiantes' });
  }

  // Logros de ejemplo
  const logrosEjemplo = [
    {
      id: 1,
      titulo: "Primera LecciÃ³n",
      descripcion: "Completaste tu primera lecciÃ³n",
      icono: "ðŸŽ¯",
      fechaObtenido: "2024-10-25"
    },
    {
      id: 2,
      titulo: "Estudiante Dedicado",
      descripcion: "5 dÃ­as consecutivos estudiando",
      icono: "ðŸ“š",
      fechaObtenido: "2024-10-27"
    },
    {
      id: 3,
      titulo: "ParticipaciÃ³n Activa",
      descripcion: "10 participaciones en foros",
      icono: "ðŸ’¬",
      fechaObtenido: "2024-10-28"
    }
  ];

  res.json(logrosEjemplo);
});

app.get('/api/student/notifications', authenticateToken, (req, res) => {
  const currentUser = users.find(u => u.id === req.user.userId);
  
  if (!currentUser || currentUser.tipo !== 'alumno') {
    return res.status(403).json({ error: 'Acceso solo para estudiantes' });
  }

  // Notificaciones de ejemplo
  const notificacionesEjemplo = [
    {
      id: 1,
      tipo: 'info',
      titulo: 'Nueva lecciÃ³n disponible',
      mensaje: 'Revisa la nueva lecciÃ³n de Integrales en MatemÃ¡ticas Avanzadas',
      fecha: 'Hace 1 hora',
      leida: false
    },
    {
      id: 2,
      tipo: 'warning',
      titulo: 'Clase programada',
      mensaje: 'Tienes una clase en vivo maÃ±ana a las 10:00 AM',
      fecha: 'Hace 3 horas',
      leida: false
    },
    {
      id: 3,
      tipo: 'success',
      titulo: 'Certificado disponible',
      mensaje: 'Tu certificado de "IntroducciÃ³n al CÃ¡lculo" estÃ¡ listo',
      fecha: 'Ayer',
      leida: true
    },
    {
      id: 4,
      tipo: 'info',
      titulo: 'Nuevo mensaje en foro',
      mensaje: 'El profesor respondiÃ³ tu pregunta en el foro de MatemÃ¡ticas',
      fecha: 'Hace 2 dÃ­as',
      leida: true
    }
  ];

  res.json(notificacionesEjemplo);
});

app.patch('/api/student/notifications/:notifId/read', authenticateToken, (req, res) => {
  const currentUser = users.find(u => u.id === req.user.userId);
  
  if (!currentUser || currentUser.tipo !== 'alumno') {
    return res.status(403).json({ error: 'Acceso solo para estudiantes' });
  }

  const notifId = parseInt(req.params.notifId);
  
  // En una implementaciÃ³n real, actualizarÃ­as la base de datos
  res.json({ 
    message: 'NotificaciÃ³n marcada como leÃ­da',
    notifId 
  });
});

// Progreso detallado del estudiante
app.get('/api/student/detailed-progress', authenticateToken, (req, res) => {
  const currentUser = users.find(u => u.id === req.user.userId);
  
  if (!currentUser || currentUser.tipo !== 'alumno') {
    return res.status(403).json({ error: 'Acceso solo para estudiantes' });
  }

  // Progreso detallado de ejemplo
  const progresoDetallado = [
    {
      cursoId: 1,
      nombreCurso: "MatemÃ¡ticas Avanzadas",
      progreso: 75,
      leccionesCompletadas: 12,
      leccionesTotales: 16,
      tiempoEstudio: "24 horas",
      ultimaActividad: "Hace 2 horas",
      proximaClase: "MaÃ±ana 10:00 AM",
      profesor: "Dr. GarcÃ­a LÃ³pez"
    },
    {
      cursoId: 2,
      nombreCurso: "Historia del Arte",
      progreso: 45,
      leccionesCompletadas: 9,
      leccionesTotales: 20,
      tiempoEstudio: "18 horas",
      ultimaActividad: "Ayer",
      proximaClase: "Viernes 2:00 PM",
      profesor: "Mtra. Ana Ruiz"
    }
  ];

  res.json(progresoDetallado);
});

// Rutas de cursos
app.get('/api/courses', authenticateToken, (req, res) => {
  res.json(courses);
});

app.post('/api/courses', authenticateToken, (req, res) => {
  const { nombre, descripcion, categoria, precio, duracion, imagen } = req.body;
  const user = users.find(u => u.id === req.user.userId);
  
  // Solo profesores pueden crear cursos
  if (user.tipo !== 'profesor') {
    return res.status(403).json({ error: 'Solo los profesores pueden crear cursos' });
  }

  const newCourse = {
    id: courses.length + 1,
    nombre,
    descripcion,
    profesor: user.nombre,
    profesorId: user.id,
    categoria,
    precio: parseFloat(precio) || 0,
    duracion,
    estudiantes: 0,
    rating: 0,
    imagen: imagen || 'ðŸ“š',
    createdAt: new Date(),
    publicado: false, // Los cursos nuevos estÃ¡n en borrador
    modulos: []
  };

  courses.push(newCourse);

  // Agregar el curso a los cursos dictados del profesor
  if (!user.cursosDictados) {
    user.cursosDictados = [];
  }
  user.cursosDictados.push(newCourse.id);

  res.status(201).json(newCourse);
});

// Obtener detalles completos de un curso con sus mÃ³dulos y lecciones
app.get('/api/courses/:id/content', authenticateToken, (req, res) => {
  const courseId = parseInt(req.params.id);
  const course = courses.find(c => c.id === courseId);
  
  if (!course) {
    return res.status(404).json({ error: 'Curso no encontrado' });
  }

  // Obtener mÃ³dulos del curso
  const courseModulos = modulos.filter(m => m.cursoId === courseId).sort((a, b) => a.orden - b.orden);
  
  // Para cada mÃ³dulo, obtener sus lecciones
  const modulosConLecciones = courseModulos.map(modulo => {
    const moduloLecciones = lecciones.filter(l => l.moduloId === modulo.id).sort((a, b) => a.orden - b.orden);
    
    // Para cada lecciÃ³n, obtener sus recursos
    const leccionesConRecursos = moduloLecciones.map(leccion => {
      const leccionRecursos = recursos.filter(r => r.leccionId === leccion.id);
      return { ...leccion, recursos: leccionRecursos };
    });
    
    return { ...modulo, lecciones: leccionesConRecursos };
  });

  res.json({ ...course, modulos: modulosConLecciones });
});

// Publicar/despublicar curso
app.put('/api/courses/:id/publish', authenticateToken, (req, res) => {
  const courseId = parseInt(req.params.id);
  const { publicado } = req.body;
  const user = users.find(u => u.id === req.user.userId);
  const course = courses.find(c => c.id === courseId);

  if (!course) {
    return res.status(404).json({ error: 'Curso no encontrado' });
  }

  // Solo el profesor propietario puede publicar
  if (course.profesorId !== user.id && user.tipo !== 'admin') {
    return res.status(403).json({ error: 'No tienes permisos para modificar este curso' });
  }

  course.publicado = publicado;
  res.json({ message: `Curso ${publicado ? 'publicado' : 'despublicado'} exitosamente`, course });
});

// === RUTAS DE MÃ“DULOS ===

// Obtener mÃ³dulos de un curso
app.get('/api/courses/:id/modules', authenticateToken, (req, res) => {
  const courseId = parseInt(req.params.id);
  const courseModulos = modulos.filter(m => m.cursoId === courseId).sort((a, b) => a.orden - b.orden);
  res.json(courseModulos);
});

// Crear mÃ³dulo
app.post('/api/courses/:id/modules', authenticateToken, (req, res) => {
  const courseId = parseInt(req.params.id);
  const { titulo, descripcion } = req.body;
  const user = users.find(u => u.id === req.user.userId);
  const course = courses.find(c => c.id === courseId);

  if (!course) {
    return res.status(404).json({ error: 'Curso no encontrado' });
  }

  // Solo el profesor propietario puede agregar mÃ³dulos
  if (course.profesorId !== user.id && user.tipo !== 'admin') {
    return res.status(403).json({ error: 'No tienes permisos para modificar este curso' });
  }

  const existingModulos = modulos.filter(m => m.cursoId === courseId);
  const newModulo = {
    id: modulos.length + 1,
    cursoId: courseId,
    titulo,
    descripcion,
    orden: existingModulos.length + 1,
    publicado: false,
    createdAt: new Date(),
    lecciones: []
  };

  modulos.push(newModulo);
  res.status(201).json(newModulo);
});

// Actualizar mÃ³dulo
app.put('/api/modules/:id', authenticateToken, (req, res) => {
  const moduloId = parseInt(req.params.id);
  const { titulo, descripcion, publicado } = req.body;
  const modulo = modulos.find(m => m.id === moduloId);

  if (!modulo) {
    return res.status(404).json({ error: 'MÃ³dulo no encontrado' });
  }

  const course = courses.find(c => c.id === modulo.cursoId);
  const user = users.find(u => u.id === req.user.userId);

  // Solo el profesor propietario puede modificar mÃ³dulos
  if (course.profesorId !== user.id && user.tipo !== 'admin') {
    return res.status(403).json({ error: 'No tienes permisos para modificar este mÃ³dulo' });
  }

  modulo.titulo = titulo || modulo.titulo;
  modulo.descripcion = descripcion || modulo.descripcion;
  modulo.publicado = publicado !== undefined ? publicado : modulo.publicado;

  res.json(modulo);
});

// === RUTAS DE LECCIONES ===

// Obtener lecciones de un mÃ³dulo
app.get('/api/modules/:id/lessons', authenticateToken, (req, res) => {
  const moduloId = parseInt(req.params.id);
  const moduloLecciones = lecciones.filter(l => l.moduloId === moduloId).sort((a, b) => a.orden - b.orden);
  
  // Agregar recursos a cada lecciÃ³n
  const leccionesConRecursos = moduloLecciones.map(leccion => {
    const leccionRecursos = recursos.filter(r => r.leccionId === leccion.id);
    return { ...leccion, recursos: leccionRecursos };
  });
  
  res.json(leccionesConRecursos);
});

// Crear lecciÃ³n
app.post('/api/modules/:id/lessons', authenticateToken, (req, res) => {
  const moduloId = parseInt(req.params.id);
  const { titulo, contenido, tipo, duracion } = req.body;
  const modulo = modulos.find(m => m.id === moduloId);

  if (!modulo) {
    return res.status(404).json({ error: 'MÃ³dulo no encontrado' });
  }

  const course = courses.find(c => c.id === modulo.cursoId);
  const user = users.find(u => u.id === req.user.userId);

  // Solo el profesor propietario puede agregar lecciones
  if (course.profesorId !== user.id && user.tipo !== 'admin') {
    return res.status(403).json({ error: 'No tienes permisos para agregar lecciones' });
  }

  const existingLecciones = lecciones.filter(l => l.moduloId === moduloId);
  const newLeccion = {
    id: lecciones.length + 1,
    moduloId: moduloId,
    titulo,
    contenido,
    tipo: tipo || 'texto', // texto, video, documento, quiz
    orden: existingLecciones.length + 1,
    duracion: parseInt(duracion) || 0,
    recursos: [],
    publicado: false,
    createdAt: new Date()
  };

  lecciones.push(newLeccion);
  res.status(201).json(newLeccion);
});

// Actualizar lecciÃ³n
app.put('/api/lessons/:id', authenticateToken, (req, res) => {
  const leccionId = parseInt(req.params.id);
  const { titulo, contenido, tipo, duracion, publicado } = req.body;
  const leccion = lecciones.find(l => l.id === leccionId);

  if (!leccion) {
    return res.status(404).json({ error: 'LecciÃ³n no encontrada' });
  }

  const modulo = modulos.find(m => m.id === leccion.moduloId);
  const course = courses.find(c => c.id === modulo.cursoId);
  const user = users.find(u => u.id === req.user.userId);

  // Solo el profesor propietario puede modificar lecciones
  if (course.profesorId !== user.id && user.tipo !== 'admin') {
    return res.status(403).json({ error: 'No tienes permisos para modificar esta lecciÃ³n' });
  }

  leccion.titulo = titulo || leccion.titulo;
  leccion.contenido = contenido || leccion.contenido;
  leccion.tipo = tipo || leccion.tipo;
  leccion.duracion = duracion !== undefined ? parseInt(duracion) : leccion.duracion;
  leccion.publicado = publicado !== undefined ? publicado : leccion.publicado;

  res.json(leccion);
});

// === RUTAS DE RECURSOS ===

// Agregar recurso a lecciÃ³n
app.post('/api/lessons/:id/resources', authenticateToken, upload.single('file'), (req, res) => {
  const leccionId = parseInt(req.params.id);
  const { nombre, tipo, url } = req.body;
  const leccion = lecciones.find(l => l.id === leccionId);

  if (!leccion) {
    return res.status(404).json({ error: 'LecciÃ³n no encontrada' });
  }

  const modulo = modulos.find(m => m.id === leccion.moduloId);
  const course = courses.find(c => c.id === modulo.cursoId);
  const user = users.find(u => u.id === req.user.userId);

  // Solo el profesor propietario puede agregar recursos
  if (course.profesorId !== user.id && user.tipo !== 'admin') {
    return res.status(403).json({ error: 'No tienes permisos para agregar recursos' });
  }

  let resourceUrl = url;
  let resourceSize = '0MB';

  // Si se subiÃ³ un archivo
  if (req.file) {
    resourceUrl = `/uploads/${req.file.filename}`;
    resourceSize = `${(req.file.size / (1024 * 1024)).toFixed(2)}MB`;
  }

  const newRecurso = {
    id: recursos.length + 1,
    leccionId: leccionId,
    nombre: nombre || req.file?.originalname || 'Recurso sin nombre',
    tipo: tipo || req.file?.mimetype.split('/')[0] || 'archivo',
    url: resourceUrl,
    tamaÃ±o: resourceSize,
    duracion: 0,
    createdAt: new Date()
  };

  recursos.push(newRecurso);
  res.status(201).json(newRecurso);
});

// === RUTAS DE PROGRESO ===

// Marcar lecciÃ³n como completada
app.post('/api/lessons/:id/complete', authenticateToken, (req, res) => {
  const leccionId = parseInt(req.params.id);
  const { tiempoVisto } = req.body;
  const user = users.find(u => u.id === req.user.userId);
  const leccion = lecciones.find(l => l.id === leccionId);

  if (!leccion) {
    return res.status(404).json({ error: 'LecciÃ³n no encontrada' });
  }

  const modulo = modulos.find(m => m.id === leccion.moduloId);
  const cursoId = modulo.cursoId;

  // Verificar si el usuario estÃ¡ inscrito en el curso
  if (!user.cursosInscritos || !user.cursosInscritos.includes(cursoId)) {
    return res.status(403).json({ error: 'No estÃ¡s inscrito en este curso' });
  }

  // Buscar progreso existente
  let progresoExistente = progreso.find(p => p.usuarioId === user.id && p.leccionId === leccionId);

  if (progresoExistente) {
    progresoExistente.completado = true;
    progresoExistente.tiempoVisto = tiempoVisto || progresoExistente.tiempoVisto;
    progresoExistente.fechaCompletado = new Date();
  } else {
    const newProgreso = {
      id: progreso.length + 1,
      usuarioId: user.id,
      cursoId: cursoId,
      leccionId: leccionId,
      completado: true,
      tiempoVisto: tiempoVisto || 0,
      fechaCompletado: new Date()
    };
    progreso.push(newProgreso);
  }

  res.json({ message: 'LecciÃ³n marcada como completada' });
});

// Obtener progreso del estudiante en un curso
app.get('/api/courses/:id/progress', authenticateToken, (req, res) => {
  const cursoId = parseInt(req.params.id);
  const user = users.find(u => u.id === req.user.userId);

  const userProgreso = progreso.filter(p => p.usuarioId === user.id && p.cursoId === cursoId);
  
  // Calcular estadÃ­sticas de progreso
  const totalLecciones = lecciones.filter(l => {
    const modulo = modulos.find(m => m.id === l.moduloId);
    return modulo && modulo.cursoId === cursoId;
  }).length;

  const leccionesCompletadas = userProgreso.filter(p => p.completado).length;
  const porcentajeProgreso = totalLecciones > 0 ? Math.round((leccionesCompletadas / totalLecciones) * 100) : 0;

  res.json({
    totalLecciones,
    leccionesCompletadas,
    porcentajeProgreso,
    progreso: userProgreso
  });
});

app.get('/api/courses/:id', authenticateToken, (req, res) => {
  const course = courses.find(c => c.id === parseInt(req.params.id));
  if (!course) {
    return res.status(404).json({ error: 'Curso no encontrado' });
  }
  res.json(course);
});

app.post('/api/courses/:id/enroll', authenticateToken, (req, res) => {
  const courseId = parseInt(req.params.id);
  const user = users.find(u => u.id === req.user.userId);
  
  if (!user.cursosInscritos.includes(courseId)) {
    user.cursosInscritos.push(courseId);
    user.progreso[courseId] = 0;
  }

  res.json({ message: 'InscripciÃ³n exitosa' });
});

// Rutas de clases en vivo
app.get('/api/courses/:id/classes', authenticateToken, (req, res) => {
  const courseId = parseInt(req.params.id);
  const courseClasses = clases.filter(c => c.cursoId === courseId);
  res.json(courseClasses);
});

app.post('/api/classes/:id/reserve', authenticateToken, (req, res) => {
  const classId = parseInt(req.params.id);
  const clase = clases.find(c => c.id === classId);
  
  if (!clase) {
    return res.status(404).json({ error: 'Clase no encontrada' });
  }

  if (!clase.estudiantes.includes(req.user.userId)) {
    clase.estudiantes.push(req.user.userId);
  }

  res.json({ 
    message: 'Clase reservada exitosamente',
    roomId: clase.roomId,
    paymentRequired: true,
    amount: clase.precio
  });
});

// Rutas de archivos
app.post('/api/upload', authenticateToken, upload.single('file'), (req, res) => {
  if (!req.file) {
    return res.status(400).json({ error: 'No se subiÃ³ ningÃºn archivo' });
  }

  res.json({
    message: 'Archivo subido exitosamente',
    file: {
      filename: req.file.filename,
      originalname: req.file.originalname,
      mimetype: req.file.mimetype,
      size: req.file.size,
      url: `/uploads/${req.file.filename}`
    }
  });
});

// ====== RUTAS DE PAGOS ======

// Crear preferencia de pago para un curso
app.post('/api/payments/create-preference', authenticateToken, async (req, res) => {
  try {
    const { courseId } = req.body;

    if (!courseId) {
      return res.status(400).json({ error: 'ID del curso requerido' });
    }

    // Buscar el curso
    const course = cursosPrueba.find(c => c.id === parseInt(courseId));
    if (!course) {
      return res.status(404).json({ error: 'Curso no encontrado' });
    }

    // Verificar configuraciÃ³n de MercadoPago
    const mpConfig = mercadoPagoService.validateConfiguration();
    if (!mpConfig.valid) {
      return res.json({
        demo: true,
        message: 'Modo demostraciÃ³n - MercadoPago no configurado',
        mockPayment: {
          id: `demo_${Date.now()}`,
          init_point: '#',
          status: 'pending'
        },
        course: course
      });
    }

    // Crear preferencia de pago
    const preference = await mercadoPagoService.createCoursePayment(course, req.user);

    res.json({
      demo: false,
      preference,
      course: course
    });

  } catch (error) {
    console.error('Error creando preferencia:', error);
    res.status(500).json({ error: 'Error interno del servidor' });
  }
});

// Webhook para notificaciones de MercadoPago
app.post('/api/payments/webhook', async (req, res) => {
  try {
    const notification = req.body;
    console.log('Webhook recibido:', notification);

    // Procesar notificaciÃ³n
    const result = await mercadoPagoService.processWebhookNotification(notification);

    if (result && result.success) {
      // Inscribir automÃ¡ticamente al usuario en el curso
      const user = usuariosPrueba.find(u => u.id === result.userId);
      if (user && !user.cursosInscritos.includes(result.courseId)) {
        user.cursosInscritos.push(result.courseId);
        console.log(`âœ… Usuario ${user.nombre} inscrito automÃ¡ticamente al curso ${result.courseId}`);
      }

      // Emitir notificaciÃ³n via Socket.IO
      io.emit('paymentSuccess', {
        userId: result.userId,
        courseId: result.courseId,
        paymentId: result.paymentData.id
      });
    }

    res.status(200).json({ received: true });

  } catch (error) {
    console.error('Error procesando webhook:', error);
    res.status(500).json({ error: 'Error procesando notificaciÃ³n' });
  }
});

// Verificar estado de pago
app.get('/api/payments/:paymentId/status', authenticateToken, async (req, res) => {
  try {
    const { paymentId } = req.params;

    // En modo demo, simular respuesta
    const mpConfig = mercadoPagoService.validateConfiguration();
    if (!mpConfig.valid) {
      return res.json({
        demo: true,
        status: 'approved',
        message: 'Pago simulado aprobado'
      });
    }

    const paymentStatus = await mercadoPagoService.getPaymentStatus(paymentId);
    res.json(paymentStatus);

  } catch (error) {
    console.error('Error verificando pago:', error);
    res.status(500).json({ error: 'Error verificando estado del pago' });
  }
});

// ConfiguraciÃ³n de MercadoPago
app.get('/api/payments/config', (req, res) => {
  const config = mercadoPagoService.validateConfiguration();
  res.json({
    configured: config.valid,
    demo: config.demo,
    message: config.message,
    publicKey: config.valid ? process.env.MERCADOPAGO_PUBLIC_KEY : null
  });
});

// ====== CONFIGURACIÃ“N DE SOCKET.IO ======

// Socket.IO para chat en tiempo real
io.on('connection', (socket) => {
  console.log('Usuario conectado:', socket.id);

  socket.on('join-course', (courseId) => {
    socket.join(`course_${courseId}`);
    console.log(`Usuario se uniÃ³ al curso ${courseId}`);
  });

  socket.on('send-message', (data) => {
    const { courseId, message, userId, userName } = data;
    const messageData = {
      id: Date.now(),
      userId,
      userName,
      message,
      timestamp: new Date()
    };
    
    socket.to(`course_${courseId}`).emit('new-message', messageData);
  });

  socket.on('join-class', (roomId) => {
    socket.join(roomId);
    console.log(`Usuario se uniÃ³ a la clase ${roomId}`);
  });

  socket.on('disconnect', () => {
    console.log('Usuario desconectado:', socket.id);
  });
});

// Ruta de salud
app.get('/api/health', (req, res) => {
  res.json({ 
    status: 'OK', 
    message: 'Campus Virtual API funcionando correctamente',
    timestamp: new Date().toISOString()
  });
});

// Middleware de manejo de errores
app.use((error, req, res, next) => {
  console.error(error);
  res.status(500).json({ error: 'Error interno del servidor' });
});

// Rutas de MercadoPago
app.post('/api/payments/create-preference', authenticateToken, async (req, res) => {
  try {
    const { courseId, courses } = req.body;
    const currentUser = users.find(u => u.id === req.user.userId);

    if (!currentUser) {
      return res.status(404).json({ error: 'Usuario no encontrado' });
    }

    let result;

    if (courseId) {
      // Pago para un solo curso
      const course = courses.find(c => c.id === courseId);
      if (!course) {
        return res.status(404).json({ error: 'Curso no encontrado' });
      }

      result = await mercadoPagoService.createPreference(course, currentUser);
    } else if (courses && courses.length > 0) {
      // Pago para mÃºltiples cursos
      const selectedCourses = courses.filter(c => c.selected);
      if (selectedCourses.length === 0) {
        return res.status(400).json({ error: 'No se seleccionaron cursos' });
      }

      result = await mercadoPagoService.createMultipleCoursePreference(selectedCourses, currentUser);
    } else {
      return res.status(400).json({ error: 'Datos de pago invÃ¡lidos' });
    }

    if (result.success) {
      res.json({
        preferenceId: result.preferenceId,
        initPoint: result.initPoint,
        sandboxInitPoint: result.sandboxInitPoint,
        totalAmount: result.totalAmount || null
      });
    } else {
      res.status(500).json({ error: result.error });
    }
  } catch (error) {
    console.error('Error creating payment preference:', error);
    res.status(500).json({ error: 'Error interno del servidor' });
  }
});

// Webhook de MercadoPago
app.post('/api/payments/webhook', async (req, res) => {
  try {
    const result = await mercadoPagoService.processWebhook(req.body, req.headers);

    if (result.success) {
      const { paymentStatus, externalReference, paymentId } = result;

      if (paymentStatus === 'approved') {
        // Extraer informaciÃ³n de la referencia externa
        const refParts = externalReference.split('_');
        
        if (refParts[0] === 'course') {
          // Pago de curso Ãºnico
          const courseId = parseInt(refParts[1]);
          const userId = parseInt(refParts[3]);
          
          // Inscribir al usuario en el curso
          const user = users.find(u => u.id === userId);
          const course = courses.find(c => c.id === courseId);
          
          if (user && course) {
            if (!user.cursosInscritos) user.cursosInscritos = [];
            if (!user.cursosInscritos.includes(courseId)) {
              user.cursosInscritos.push(courseId);
              course.estudiantes += 1;
              
              console.log(`âœ… Usuario ${user.nombre} inscrito en curso ${course.nombre} - Pago: ${paymentId}`);
            }
          }
        }
      }

      res.status(200).json({ received: true });
    } else {
      res.status(400).json({ error: result.error });
    }
  } catch (error) {
    console.error('Error processing webhook:', error);
    res.status(500).json({ error: 'Error interno del servidor' });
  }
});

// Obtener informaciÃ³n de pago
app.get('/api/payments/:paymentId', authenticateToken, async (req, res) => {
  try {
    const { paymentId } = req.params;
    const result = await mercadoPagoService.getPayment(paymentId);

    if (result.success) {
      res.json(result.payment);
    } else {
      res.status(404).json({ error: result.error });
    }
  } catch (error) {
    console.error('Error getting payment:', error);
    res.status(500).json({ error: 'Error interno del servidor' });
  }
});

// Iniciar servidor
server.listen(PORT, () => {
  console.log(`ðŸš€ Servidor funcionando en puerto ${PORT}`);
  console.log(`ðŸ“¡ API disponible en http://localhost:${PORT}/api`);
  console.log(`ðŸ’¬ Socket.IO listo para conexiones en tiempo real`);
  console.log(`ðŸ’³ MercadoPago configurado y listo`);
});

module.exports = app;
